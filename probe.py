# Домашнее задание по уроку Генерация функций.
# Цель задания:
#   Научиться создавать функции динамически в зависимости от заданных условий и параметров, используя различные подходы,
# такие как фабрики функций, лямбда-функции и вызываемые объекты.
#
# Теоретический комментарий:
# 1. Динамическое определение функций (def):
#   В Python можно определять функции внутри других функций. Такие функции могут создаваться и возвращаться. Это основа
# для создания "фабрик функций" - функций, создающих функции.
#
# 2. Лямбда-функции:
#   Лямбда-функции в Python — это анонимные функции, определённые одной строкой. Они удобны для создания простых функций
# на лету, особенно когда функция нужна временно или для одноразового использования.
#
# 3. Вызываемые объекты (__call__):
#   В Python у класса может быть метод __call__, что позволяет его экземплярам вести себя как функции. Это дает возможность
# создавать объекты, которые могут быть вызваны как функции и хранить состояние между вызовами.
# Задание:
# Задача 1: Фабрика Функций
# Написать функцию, которая возвращает различные математические функции (например, деление, умножение) в зависимости от
# переданных аргументов.
#
# Задача 2: Лямбда-Функции
# Использовать лямбда-функцию для реализации простой операции и написать такую же функцию с использованием def. Например,
# возведение числа в квадрат
#
# Задача 3: Вызываемые Объекты
# Создать класс с Rect c полями a, b которые задаются в __init__ и методом __call__, который возвращает площадь
# прямоугольника, то есть a*b.
def create_operation(operation):
    if operation == "multiply":
        def multiply(x, y):
            return x * y
        return multiply
    elif operation == "divide":
        def divide(x, y):
            return x / y
        return divide
my_func_multiply = create_operation("multiply")
print(f'Умножение:', my_func_multiply(4,2))
my_func_divide = create_operation("divide")
print(f'Деление:', my_func_divide(4,2))

exponentiation = lambda x, y: x ** y
print(f'Возведение в степень:', exponentiation(2, 3))

def exponentiation_def(x, y):
   return x ** y
print(f'Возведение в степень:', exponentiation_def(2, 3))

class Repeater:

   def __init__(self, a, b):
       self.a = a
       self.b = b
   def __call__(self):
       return self.a * self.b

repeat_five = Repeater(5, 2)
print(f'Площадь:', repeat_five())

